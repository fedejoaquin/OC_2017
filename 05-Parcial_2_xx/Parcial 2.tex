% !TeX spellcheck = es_AR
%
% Organización de Computadoras,
%

\documentclass[12pt,a4paper]{article}
\input{estilo/Catedras.sty}

\usepackage{enumerate}
\usepackage{amsmath}

\newcounter{ctej}
\setcounter{ctej}{1}
\newcommand{\ejercicio}{\vspace{1em}\noindent\textbf{Ejercicio \arabic{ctej}.} \addtocounter{ctej}{1}}

\usepackage{vwcol}

\begin{document}

\Examen{Segundo Examen Parcial}

\

%BEGIN_FOLD Norma IEEE 754

\ejercicio En el marco de la norma IEEE 754, considerando la representación en punto flotante de media precisión: mantisa fraccionaria en signo magnitud con hidden bit, exponente en exceso y base 2 y la siguiente distribución de bits:
\begin{center}
\begin{tabular}{|c|c|c|}\hline
 Sig (1b) & Exponente (5 bits) & Mantisa (10 bits)\\\hline
\end{tabular}
\end{center}

Dados los números:\quad
$$X = (1\; 10010\; 1101001010) \quad Y = (0\; 10101\; 0010110110)$$


Realizar el producto $X \times Y$ aplicando redondeo hacia $-\infty$ y hacia $+\infty$, explicando cada uno de los pasos involucrados e indicando claramente qué se hace con los bits G, R y S del resultado y con R y S al redondear. El resultado debe ser expresando según la representación enunciada.



%\ begin{verbatim}
% exponente X = 10010 - 1111 = 11
% exponente Y = 10101 - 1111 = 110
%
%          1.1101001010 x 2^3
% x        1.0010110110 x 2^6
% ------------------------
% 10.001001010|11010011100 x 2^9
%              GR----S=1
%
% Normalizar - No entra G
% 1.0001001010|11010011100 x 2^10
%              R----S=1
%\end{verbatim}
             

\ejercicio En el marco de la norma IEEE 754, considerando la misma representación y los mismos números que en el ejercicio anterior: 

Realizar la suma $X + Y$ aplicando redondeo por proximidad \textit{unbiased} (hacia los pares), explicando cada uno de los pasos involucrados e indicando claramente qué se hace con los bits G, R y S del resultado y con R y S al redondear. El resultado debe ser expresando según la representación enunciada.

%\begin{verbatim}
% X=-1.1101001010 x 2^3
% Y= 1.0010110110 x 2^6
%
% X'=-0.0011101001010 x 2^6
% Y = 1.0010110110    x 2^6
%
% X'=-0.0011101001010 x 2^6
% Y = 1.0010110110    x 2^6
%
% swap
% Y = 1.0010110110    x 2^6
% X'=-0.0011101001010 x 2^6
%
% complementar X
% Y = 1.0010110110    x 2^6
% X'= 1.1100010110|110 x 2^6
% --------------------------
%  (1)0.1111001100|110 x 2^6
%                  GRS
%
% Normalizar=> entra G
% 1.1110011001|10 x 2^5
%              RS
%\end{verbatim}

%END_FOLD

%BEGIN_FOLD Arquitecturas

\ejercicio Asumiendo que se cuenta en todos los casos con las instrucciones \texttt{add} y \texttt{mpy}. Encontrar una secuencia de instrucciones que resulte óptima en tiempo de ejecución (es decir, que \textit{minimice la cantidad de accesos a memoria}), y cuya ejecución tenga como resultado la evaluación de la siguiente expresión aritmética: \\[-0.6cm]
\begin{center}
$B = A \times A \times A + B \times (D + B)$
\end{center}
Las etiquetas denotan las \textit{direcciones de memoria} que contienen los valores sobre los que se quiere operar. 

Para cada uno de los siguientes incisos determine:\begin{itemize} \itemsep5pt \parskip-5pt 
	\item el número de instrucciones.
	\item el número de accesos a memoria realizados tanto para lectura como para escritura de datos.
	\item el espacio en memoria ocupado teniendo en cuenta que:\begin{itemize}
		\item las instrucciones tipo PILA de 1 dirección ocupan 3 bytes y las de 0 direcciones, 1 byte.
%		\item las tipo \texttt{INTEL} ocupan 2 bytes las de 0 direcciones (solo registros), 4 bytes las de 1 dirección (sin registros) y 6 bytes las de 1 dirección más registros 
		\item las instrucciones tipo VAX de 0 direcciones ocupan 2 bytes, las de 1 dirección ocupan 4 bytes, las de 2 direcciones ocupan 6 bytes y las de 3 direcciones, 8 bytes.
	\end{itemize} 
\end{itemize}

\begin{enumerate}[a)]\itemsep0pt
%\item Asumiendo una arquitectura estilo ACUMULADOR con operaciones de 1 dirección, que cuenta con las instrucciones \texttt{load} y \texttt{store} para acceder a memoria.

\item Asumiendo una arquitectura de 0--direcciones (tipo \texttt{PILA}), con las instrucciones \texttt{push} y \texttt{pop} para acceder a memoria y la instrucción \texttt{dup} que duplica el tope de la pila.

%\item Asumiendo una arquitectura estilo RISC con operaciones registro a registro, sin limitaciones en cuanto a los registros disponibles, y las instrucciones ld (load) y st (store) para acceder a memoria, y la instrucción 0lda (load address). Las operaciones aritméticas operan con dos operandos (dst/fte , fte).

%\item Asumiendo una arquitectura tipo \texttt{INTEL} con operaciones 1--dirección más registros, sin limitaciones en cuando a los registros disponibles, que cuenta con la instrucción \texttt{mov} para acceder a memoria y donde las operaciones aritméticas operan con tres operandos \texttt{(dst, fte, fte)}.
%en lugar de \texttt{load} y \texttt{store}

\item Asumiendo una arquitectura tipo \texttt{VAX} con operaciones que admiten hasta 3 direcciones de memoria, donde las operaciones aritméticas operan con tres operandos \texttt{(dst, fte, fte)}.





\end{enumerate}
%END_FOLD

\newpage

%BEGIN_FOLD OCUNS

\ejercicio Considerando el siguiente programa para la arquitectura OCUNS, en la que toda lectura/escritura de/en la dirección FFh es atrapada y re{}direccionada a la entrada/salida estándar y el registro \texttt{RF} está cableado a 0: \\[-8mm]
\begin{center}
\begin{minipage}{.1\textwidth}\begin{footnotesize}
\tt
\begin{tabbing}
\qquad\qquad\= \\
        \> lda   R5, FF     \\ %00:85ff;        lda    r5    f    f
        \> load  R1, 0(R5)  \\ % 02:6150;        load    r1    r5    0
        \> jz    R1, \textbf{fin1}    \\ % 1C:9108;        jz    r1        8
        \> xor   RA, R1, R1 \\ % 18:0aff;    sum    add    ra    rf    rf
loop1:    \> call  R4, \textbf{rut}    \\ % 1E:B40A;    loop2    call    r4    0    A
        \> add   RA, RA, RC \\ % 20:0aac;        add    ra    ra    rc
        \> dec   R1         \\ % 22:E100;        dec    r1    -    -
        \> jg    R1, \textbf{loop1}    \\ % 24:A1F8;        jg    r1        F8
fin1:    \> store RA, O(R5)  \\ % 06:75a0;        store    r5    ra    0
        \> hlt              \\ % 08:F000;        hlt    -    -    -
rut:    \> add   RC, RF, RF \\ % 0A:0cff;    mult    add    rc    rf    rf
        \> add   RB, RF, R1 \\ % 0C:0bf1;        add    rb    rf    r1
        \> jz    RB, \textbf{fin2}    \\ % 0E:9b06;        jz    rb        6
loop2:    \> add   RC, RC, R1 \\ % 10:0cc1;    loop1    add    rc    rc    r1
        \> dec   RB         \\ % 12:Eb00;        dec    rb    -    -
        \> jg    RB, \textbf{loop2}    \\ % 14:AbFA;        jg    rb        FA
fin2:    \> jmp   R4         \\ % 16:C400;    fin1    jmp    r4    -    -

\end{tabbing}
\end{footnotesize}
\end{minipage}
\quad%
\begin{minipage}{.7\textwidth}
\begin{center}
	\begin{small} %
	\begin{tabular}{|c|l|c|l|}\hline
	\textsf{Op.} &
	\textsf{Descr.} &
	\textsf{FMT.} &
	\textsf{Pseudoc\'odigo} \\ \hline
	\textbf{0} & \textsf{add}   & \textbf{I}   & \texttt{R[d] $\leftarrow$ R[s] + R[t]} \\
	\textbf{1} & \textsf{sub}   & \textbf{I}   & \texttt{R[d] $\leftarrow$ R[s] - R[t]} \\
	\textbf{2} & \textsf{and}   & \textbf{I}   & \texttt{R[d] $\leftarrow$ R[s] \& R[t]} \\
	\textbf{3} & \textsf{xor}   & \textbf{I}   & \texttt{R[d] $\leftarrow$ R[s] \^{} R[t]} \\
	\textbf{4} & \textsf{lsh}   & \textbf{I}   & \texttt{R[d] $\leftarrow$ R[s] <{}<{} R[t]} \\
	\textbf{5} & \textsf{rsh}   & \textbf{I}   & \texttt{R[d] $\leftarrow$ R[s] >{}>{} R[t]} \\
	\textbf{6} & \textsf{load}  & \textbf{I}   & \texttt{R[d] $\leftarrow$ mem[offset + R[s]]} \\
	\textbf{7} & \textsf{store} & \textbf{I}   & \texttt{mem[offset + R[d]] $\leftarrow$ R[s]} \\
	\textbf{8} & \textsf{lda}   & \textbf{II}  & \texttt{R[d] $\leftarrow$ addr} \\
	\textbf{9} & \textsf{jz}    & \textbf{II}  & \texttt{if (R[d] == 0) PC $\leftarrow$ PC + offset} \\
	\textbf{A} & \textsf{jg}    & \textbf{II}  & \texttt{if (R[d] >{} 0) PC $\leftarrow$ PC + offset} \\
	\textbf{B} & \textsf{call}  & \textbf{II}  & \texttt{R[d] $\leftarrow$ PC; PC $\leftarrow$ addr} \\
	\textbf{C} & \textsf{jmp}   & \textbf{III} & \texttt{PC $\leftarrow$ R[d]} \\
	\textbf{D} & \textsf{inc}   & \textbf{III} & \texttt{R[d] $\leftarrow$ R[d] + 1} \\
	\textbf{E} & \textsf{dec}   & \textbf{III} & \texttt{R[d] $\leftarrow$ R[d] - 1} \\
	\textbf{F} & \textsf{hlt}   & \textbf{III} & \texttt{exit} \\ \hline
	\end{tabular}
	\end{small}
	
	\begin{small}\sffamily
		\newcommand{\mc}[2]{\multicolumn{#1}{|c|}{#2}}
		\begin{tabular}{*{17}{c}}
			\textsf{Formato}   & 15 & 14       & 13       & 12       & 11 & 10 & 9 & 8 & 7 & 6 & 5 & 4  & 3 & 2 & 1 & 0         \\ \hline
			\mc{1}{\textbf{I}} & 0  & $\times$ & $\times$ & $\times$ & \mc{4}{dest. d} & \mc{4}{src. s} & \mc{4}{src. t / off.} \\ \hline
			\mc{1}{\textbf{II}} & 1 & 0        & $\times$ & $\times$ & \mc{4}{dest. d} & \mc{8}{address addr}                   \\ \hline
			\mc{1}{\textbf{III}} & 1 & 1       & $\times$ & $\times$ & \mc{4}{dest. d} & \mc{8}{-}                              \\ \hline
		\end{tabular}
	\end{small}
\end{center}	
\end{minipage}\\[2mm]
\end{center}

%\begin{center}
%\begin{small}
%	\newcommand{\mc}[2]{\multicolumn{#1}{|c|}{#2}}
%	\begin{tabular}{*{17}{c}}
%	\textsf{Formato} &
%	15 & 14 & 13 & 12 & 11 & 10 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\ \hline
%	\mc{1}{\textbf{I}} & 0 & $\times$ & $\times$ & $\times$ &
%	\mc{4}{dest. d} &
%	\mc{4}{src. s} &
%	\mc{4}{src. t / off.} \\ \hline
%	\mc{1}{\textbf{II}} & 1 & 0 & $\times$ & $\times$ &
%	\mc{4}{dest. d} &
%	\mc{8}{address addr} \\ \hline
%	\mc{1}{\textbf{III}} & 1 & 1 & $\times$ & $\times$ &
%	\mc{4}{dest. d} &
%	\mc{8}{-} \\ \hline
%	\end{tabular}
%\end{small}
%\end{center}

\begin{enumerate}[a)]\itemsep0pt
\item Ensamblar el programa a partir de la dirección 00h. \label{ensamblado}

\item Indicar cómo recibe los argumentos de entrada la rutinas \texttt{lb1}, cómo devuelve el resultado y qué consideraciones debe tener el programa que la invoque en cuanto a registros utilizados.

\item Describir claramente qué hace la rutina y el programa. A partir del ensamblado del inciso (\ref{ensamblado}), realice una traza considerando que se ingresa por teclado el número 04h.

\item Reubicar el código máquina obtenido en el inciso (\ref{ensamblado}) a partir de la dirección 23h. Justificar adecuadamente cuáles de las referencias a memoria requieren ser ajustadas y cuáles no.

\end{enumerate}

% ####################################################################

\ejercicio Considerando la arquitectura OCUNS descripta en el ejercicio anterior, indicar una secuencia de instrucciones de dicha arquitectura equivalente a cada uno de los siguientes códigos:

\begin{center}
\noindent\textbf{(a)}
\begin{minipage}[t]{0.2\textwidth}\small
\begin{verbatim}
if (RA <= 5) R3++;
else R3--;
\end{verbatim}
\end{minipage}
\qquad
\textbf{(b)}
%\begin{minipage}[t]{0.25\textwidth}\small
%\begin{verbatim}
%while (RA > 0 && RB > 0)
%{
%    R3 = R3 + RA - R3;
%    RA--;
%    RB--;
%}
%\end{verbatim}
%\end{minipage}
%\qquad
%\textbf{(c)}
\begin{minipage}[t]{0.25\textwidth}\small
\begin{verbatim}
R3 = 0;
for (RA = 0; RA < 10; RA++)
    R3 += RA;

\end{verbatim}
\end{minipage}
\end{center}

%END_FOLD



\ejercicio
Asumiendo que en la posición 3502h de la memoria se tiene el valor 123h y en la 2002h el valor 3502h y el PC tiene el valor 5002h, para cada tipo de direccionado indicar el registro R\textsubscript{\textquestiondown ?} correcto o bien el valor \#\# que corresponda para acceder al operando de valor 123h.\\[2mm]

\begin{minipage}{0.3\textwidth}
Registros:\\
\begin{tabular}{c|c|}\cline{2-2}
	R\textsubscript{0} & 0h \\\cline{2-2}
	R\textsubscript{1} & 3502h \\\cline{2-2}
	R\textsubscript{2} & 123h \\\cline{2-2}
	R\textsubscript{3} & 1502h \\\cline{2-2}
\end{tabular}
\end{minipage}
%
%\columnbreak
\begin{minipage}{0.6\textwidth}
\begin{enumerate}[a)]\itemsep0pt
\item Modo Registro:               OPCODE   R\textsubscript{\textquestiondown ?}
\item Modo Absoluto Indirecto:     OPCODE   \#\# 
\item Modo Indexado:               OPCODE   2000h (R\textsubscript{\textquestiondown ?}) 
%\item Modo Pre-Indexado Indirecto: OPCODE   (R\textsubscript{3}, \#\#) 
%\item Modo Pos-Indexado Indirecto: OPCODE   (2002h) R\textsubscript{\textquestiondown ?}
\item Modo PC relativo:            OPCODE   \#\# (PC)
%\item Modo PC relativo indirecto:  OPCODE   (\#\# (PC))
\end{enumerate}

\end{minipage}

\begin{center}
(Observación: ¡No resolver en la hoja del enunciado!)
\end{center}

%\begin{tabular}{clcl}\hline
%a) & Modo Registro & OPCODE & R¿? \\\hline
%b) & Modo Absoluto Indirecto & OPCODE & \#\# \\\hline
%c) & Modo Indexado & OPCODE & 4.000(R¿?) \\\hline
%d) & Modo Pre-Indexado Indirecto & OPCODE & (R3, \#\#) \\\hline
%e) & Modo Pos-Indexado Indirecto & OPCODE & (4.000) R¿? \\\hline
%f) & Modo PC relativo & OPCODE & \#\# (PC)\\\hline
%g) & Modo PC relativo indirecto & OPCODE & (\#\# (PC))\\\hline
%\end{tabular}





\end{document}